\documentclass[12pt]{article}

\usepackage{report}
\usepackage{braket}
\usepackage{amsthm}

\orgname{COM SCI 239}
\project{Quantum Programming}
\title{Algorithms in PyQuil}
\author{Arjun Raghavan and Bryan Pan}
\date{May 12, 2020}
\contentsfalse

\newtheorem{lemma}{Lemma}

\begin{filecontents}{\jobname.bib}
    @techreport{pep8,
        author  = {Guido van Rossum and Barry Warsaw and Nick Coghlan},
        title   = {Style Guide for {Python} Code},
        year    = {2001},
        type    = {PEP},
        number  = {8},
        url     = {https://www.python.org/dev/peps/pep-0008/},
    },
    @article{numpy,
        author={S. {van der Walt} and S. C. {Colbert} and G. {Varoquaux}},
        journal={Computing in Science \& Engineering},
        title={The {NumPy} Array: A Structure for Efficient Numerical Computation},
        year={2011},
        volume={13},
        number={2},
        pages={22-30},
    },
    @book{python3,
        author = {Van Rossum, Guido and Drake, Fred L.},
        title = {Python 3 Reference Manual},
        year = {2009},
        isbn = {1441412697},
        publisher = {CreateSpace},
        address = {Scotts Valley, CA}
    }
\end{filecontents}

\begin{document}
\mktitle
\startbody

\section{Overview}
\section{Design}

\subsection{Implementing the black-box quantum oracle}

All four algorithms take as input a function $f$ in the form:
\[
    f : \{0,1\}^n \to \{0,1\}^m
\]
In the case of Deutsch-Josza, Bernstein-Vazirani, and Grover, we have $m=1$.
Simon, on the other hand, has $m=n$.

For Deutsch-Josza, Bernstein-Vazirani, and Simon, the quantum oracle of $f$, denoted $U_f$, is defined as:
\[
    U_f\ket{x}\ket{b} = \ket{x}\ket{b \oplus f(x)}
\]
Here, we have $b \in \{0,1\}^m$.
The $\oplus$ operator represents bitwise XOR, or equivalently bitwise addition mod 2.

Grover's algorithm makes use of a gate denoted by $Z_f$, which is defined as:
\[
    Z_f\ket{x} = (-1)^{f(x)}\ket{x}
\]
Notice that this is precisely the application of the phase kickback trick for gates of a form equivalent to $U_f$ where $\ket{b} = \ket{-}$:
\[
    Z_f\ket{x}\ket{-} = (-1)^{f(x)}\ket{x}\ket{-}
\]
Clearly, we can also define $Z_f$ as a quantum oracle for Grover's algorithm in the same way $U_f$ was defined for the three other algorithms.
Given that all four algorithms' quantum oracles have the same general form, we created a single function which could generate a quantum oracle and reused it for each program.

\subsubsection{Mathematical explanation}

\begin{lemma}
    $\sum_{q \in \{0,1\}^k}{\ket{q}\bra{q}} = I_{2^k}$ where $I_{2^k}$ is the identity matrix in $\mathcal{H}_{2^k}$ (corresponding to $k$ qubits).
\end{lemma}

\begin{proof}
    Let $q \in \{0, 1\}^k$.
    We have $\ket{q} = \begin{bmatrix} q_1 & q_2 & \dots & q_{2^k} \end{bmatrix}^T$ where $q_i = 1$  for some $1 \le i \le 2^k$ and $q_j = 0$ for all $j \neq i$.
    Then, $\ket{q}\bra{q}$ is a $2^k \times 2^k$ matrix of the form$ \begin{bmatrix} q_{ab} \end{bmatrix}$ where:
    \[
        q_{ab} =
        \begin{cases}
            1 & \text{if } a = b = i \\
            0 & \text{otherwise}
        \end{cases}
    \]

    For $\alpha, \beta \in \{0,1\}^k$ such that $\alpha \neq \beta$, we have $\ket{\alpha} \neq \ket{\beta} \implies \ket{\alpha}\bra{\alpha} \neq \ket{\beta}\bra{\beta}$.
    Thus:
    \begin{align*}
        \sum_{q \in \{0,1\}^k}{\ket{q}\bra{q}} &=
            \begin{bmatrix}
                1 & 0 & \dots & 0 \\
                0 & 0 & \dots & 0 \\
                \vdots & \vdots & \ddots & \vdots \\
                0 & 0 & \dots & 0
            \end{bmatrix} +
            \begin{bmatrix}
                0 & 0 & \dots & 0 \\
                0 & 1 & \dots & 0 \\
                \vdots & \vdots & \ddots & \vdots \\
                0 & 0 & \dots & 0
            \end{bmatrix} + \dots + 
            \begin{bmatrix}
                0 & 0 & \dots & 0 \\
                0 & 0 & \dots & 0 \\
                \vdots & \vdots & \ddots & \vdots \\
                0 & 0 & \dots & 1
            \end{bmatrix} = I_{2^k}
    \end{align*}
\end{proof}

Consider the application of $U_f$ to the outer product of $\ket{x}\ket{b}$ with itself:
\begin{align*}
    U_f \ket{x}\ket{b}\bra{x}\bra{b} &= \ket{x}\ket{b \oplus f(x)} \bra{x}\bra{b} \\
                                     &= \ket{x}\bra{x} \ket{b \oplus f(x)}\bra{b} \\
\end{align*}

Let $k = n+m$. By taking the sum of this over all bit strings $xb \in \{0,1\}^k$, we get:
\begin{align*}
    \sum_{xb \in \{0,1\}^{k}}U_f\left(\ket{x}\ket{b}\bra{x}\bra{b}\right)
        &= U_f \left(\sum_{xb \in \{0,1\}^{k}}\ket{x}\ket{b}\bra{x}\bra{b}\right) \\
        &= U_f \circ I_{2^{k}} \\
        &= U_f
\end{align*}

And so:
\begin{equation}\label{eq:1}
        U_f = \sum_{xb \in \{0,1\}^{k}}\ket{x}\bra{x} \ket{b \oplus f(x)}\bra{b}
\end{equation}

\subsubsection{Python implementation}

As shown in \autoref{code:py-uf}, \autoref{eq:1} is straightforwardly implemented in Python thanks to the \href{https://numpy.org/}{\texttt{numpy}} library using methods such as \texttt{np.kron} (the Kronecker product is a special case of the tensor product over complex matrices and is the nomenclature used by \texttt{numpy}) and \texttt{np.outer} \cite{numpy}.
Notice in line 155 that \texttt{f} is a dictionary, not a function.
Indeed, we chose to treat the input function $f$ for all four programs as a dictionary (or a "mapping" as we mostly referred to it) for a few reasons.

For one, this would allow a user more flexibility in providing $f$ as an input to our programs without having to possibly construct tedious \texttt{if-elif} statements.
In addition, this allowed us to more easily test our programs---we could randomly generate dictionaries representing functions which followed whatever assumptions were required for each algorithm.
An example of this for Deutsch-Josza can be seen in \autoref{code:py-init}.

Our implementation of generating $U_f$ with this generalized method had the additional benefit of making it very easy to parametrize our solutions in $n$.
The \texttt{oracle.gen\_matrix} method, along with any other methods which require the dimension of the domain and/or range of $f$, accepts \texttt{n} and \texttt{m} (as defined previously) as arguments.
While \texttt{m} is algorithm-dependent and so assigned inside the code, the user can pass in a value for $n$ using the \texttt{--num} option\footnote{Discussed in further detail in the README.}.

\codesnippet[language=Python, linerange={127-148}, firstnumber=148]{../oracle.py}{Excerpt from the \texttt{gen\_matrix} function in \texttt{oracle.py} showing the implementation of \autoref{eq:1} using \texttt{numpy}}{py-uf}

\codesnippet[language=Python, linerange={43-56}, firstnumber=43]{../oracle.py}{Excerpt from the \texttt{init\_bit\_mapping} function in \texttt{oracle.py} showing how we randomly generate a function for testing Deutsch-Josza.}{py-init}

\subsubsection{Readability}

There were a couple of possible approaches we could have taken to iterating over all $xb \in \{0,1\}^{n+m}$, including nested \texttt{for} loops or generating the entire set of bit strings and iterating over that.
We eventually settled on the approach seen in \autoref{code:py-uf}, which we felt was more elegant.

The dimension of $\{0,1\}^{n+m} =: S$ is $2^{n+m}$.
Furthermore, each element of $S$ is a bitstring which has a decimal equivalent.
Thus, it would be just as effective to iterate through each of these decimal equivalents, convert them to binary, and extract $x$ and $b$, which is precisely what we did.
We felt that this was more concise than generating the entirety of $S$ or nesting \texttt{for} loops while still maintaining some clarity of our approach.

In more general terms, we made sure to thoroughly comment our code wherever we felt it was necessary.
Our primary functions all have PyDocs (loosely conforming to PEP/8 guidelines \cite{pep8}), and further comments are added when specific lines of code require further clarification.
Overall, though, our code is self-documenting as much as possible.
We have also taken care to maintain limited line lengths (keeping 80 characters as a soft limit) and proper indentation (although the Python language just about forces the latter).

\section{Evaluation}

\subsection{Shared code}
As opposed to copying identical sections of code between each of our four programs, we opted to have a central module, \texttt{oracle.py}, which contains common code relating to the generation of functions $f$ (bit mappings, to be precise) and quantum oracles, which was discussed in the previous section.

Of course, there is still some duplication of code between programs.
Each program has a \texttt{getUf} function (named \texttt{getZf} for Grover) which checks if a $U_f$ matrix for the desired value of $n$ has already been generated and stored\footnote{This generation and storing of matrices ahead of actually running the algorithms is discussed in the README.},
in which case it loads it from its file; otherwise, it simply generates a new $U_f$.
All the implementations of this function are identical.

Also, our programs use the \href{https://docs.python.org/3/library/argparse.html}{\texttt{argparse}} library \cite{python3} to read and process user-defined options\footnote{Also discussed in the README.}.
The code for doing so is largely the same across programs, save for some minor algorithm-specific differences (like the names).

Overall, we estimate that each program file has an average of approximately 38 lines of code that is shared (within a reasonable threshold of a few characters' difference) with the other files.
Excluding \texttt{oracle.py}, the average length of a single program's Python file is 122 lines.
As such, the percentage of shared code between programs is approximately 31\%.

There are certainly avenues for reducing code reuse.
We began to adopt a \texttt{class} structure for the entire project, having each algorithm inherit from an \texttt{Algo} class which itself had methods common to all four programs.
This can in fact be seen in the code for \texttt{dj.py} and \texttt{bv.py}.
However, this was abandoned mostly due to the fact that the assignment required individual files for each program, and so this would end up unnecessarily increasing the amount of code reused between files.

\subsection{Testing}

\begin{itemize}
    \item Discuss your effort to test the two programs and present results from the testing.  Discuss whether different cases of $U_f$ lead to different execution times.
\end{itemize}

\subsection{Scalability}

\begin{itemize}
    \item What is your experience with scalability as n grows?  Present a diagram that maps n to execution time.
\end{itemize}

\section{Reflection on PyQuil}

\textbf{TODO: Answer the following:}
\begin{itemize}
    \item List three aspects of quantum programming in PyQuil that turned out to be easy to learn and list three aspects that were difficult to learn.
    \item List three aspects of quantum programming in PyQuil that the language supports well and list three aspects that PyQuil supports poorly.
    \item Which feature would you like PyQuil to support to make the quantum programming easier?  
    \item List three positives and three negatives of the documentation of PyQuil.  
    \item In some cases, PyQuil has its own names for key concepts in quantum programming.  Give a dictionary that maps key concepts in quantum programming to the names used in PyQuil.
    \item How much type checking does the PyQuil implementation do at run time when a program passes data from the classical side to the quantum side and back?

\end{itemize}

\bib{unsrt}

\end{document}
